# tree-walk Lox interpreter in Go

a standalone implementation of the Lox language from Crafting Interpreters, featuring a full scanner, parser, AST generation, pretty-printer, and tree-walk evaluator with first-class functions and native host bindings. written in Go without external dependencies.

## components

### [scanner/lexer (`cmd/myinterpreter/scanner.go`)](cmd/myinterpreter/scanner.go)
- tokenizes Lox source into a sequence of `Token` structs  
- handles single-character tokens, multi-character operators (`==`, `!=`, `<=`, `>=`), string literals, numeric literals, and identifiers  
- recognizes reserved keywords (`and`, `class`, `else`, `false`, `for`, `fun`, `if`, `nil`, `or`, `print`, `return`, `true`, `var`, `while`)  
- reports lexical errors with line numbers and continues scanning for robust error recovery  

### [AST code generator (`cmd/myinterpreter/tool/ast_codegen.go` & `grammar.json`)](cmd/myinterpreter/tool/ast_codegen.go)
- uses [`grammar.json`](./grammar.json), which defines production rules analogous to Backusâ€“Naur form (https://craftinginterpreters.com/appendix-i.html#syntax-grammar)
- emits `ast.generated.go` based on a template containing visitor interfaces and concrete AST node structs for each production  
- visitor pattern: each AST node implements `Accept(visitor Visitor)` to invoke the correct `VisitX()` method  

### [parser (`cmd/myinterpreter/parser.go`)](cmd/myinterpreter/parser.go)
- implements a recursive-descent parser for Lox grammar  
- constructs a typed AST (`Expr` and `Stmt` nodes) using the visitor-based structure generated by `ast_codegen.go`  
- supports expressions (binary, unary, grouping, literal, variable, assignment, logical, and function calls) and statements (expression, print, variable declaration, function, return, block, if, while, for)  
- uses `synchronize()` to skip tokens and recover from parse errors  

### [interpreter (`cmd/myinterpreter/ast_interpreter.go`)](cmd/myinterpreter/ast_interpreter.go)
- implements `ExprVisitor` and `StmtVisitor` to evaluate AST nodes in a tree-walk fashion  
- supports runtime features:  
  - arithmetic, comparison, logical operators with Lox semantics  
  - short-circuit evaluation for `and` / `or`  
  - variable resolution and assignment with lexical scoping  
  - control flow (if, while, for loops)  
  - function declarations, calls, closures, and return unwinding  
  - native host bindings (e.g., `clock()` returns the current UNIX timestamp)  
- maintains `Environment` chains for nested scopes and closures  
- prints runtime errors to `stderr` and halts evaluation on errors  


### [callable & native functions (`cmd/myinterpreter/callable.go`)](cmd/myinterpreter/callable.go)
- defines the `LoxCallable` interface with `Arity()` and `Call()` methods  
- implements `LoxFunction` for user-defined functions with closure support  
- includes `ClockFunc` as a built-in native function example  
- supports first-class functions and proper call semantics


### [environment & variable resolution (`cmd/myinterpreter/environment.go`)](cmd/myinterpreter/environment.go)
- implements `Environment` struct to store variable bindings in a map and a pointer to an enclosing environment  
- `Define(name, value)` adds a new variable to the current environment  
- `Assign(name, value)` searches lexical chain to update existing binding or reports an undefined variable error  
- `Get(name)` retrieves variable values, traversing enclosing scopes for lexical lookups

  
### [AST pretty-printer (`cmd/myinterpreter/ast_prettyprinter.go`)](cmd/myinterpreter/ast_prettyprinter.go)
- implements `ExprVisitor` and `StmtVisitor` stubs to produce parenthesized prefix notation for debugging and visualization  
- recursively visits AST nodes to generate human-readable representations of expressions and statements  
- used in the `parse` command to print a parsed expression or statement instead of evaluating it  


### [main & command-line interface (`cmd/myinterpreter/main.go`)](cmd/myinterpreter/main.go)
- exposes four primary commands:
  - `tokenize <file>`: prints all tokens identified by the scanner  
  - `parse <file>`: parses the first expression in the file and pretty-prints it  
  - `evaluate <file>`: parses and directly evaluates a single expression, printing the result  
  - `run <file>`: parses and executes a sequence of statements (full program)  
- integrates scanner, parser, pretty-printer, and interpreter for a single-binary CLI  
- reports usage errors, parse errors, and runtime errors with appropriate exit codes  
- logs debug messages to `stderr` (e.g., scanning and parsing diagnostics)  

## technical highlights
- **full Lox language support**:  
  - expressions: binary, unary, grouping, literal (numbers, strings, booleans, `nil`), variables, assignments, logical operators, and function calls  
  - statements: expression, print, variable declaration, function and return, block, if/else, while, for loops  
  - first-class functions with closures and lexical scoping  

- **visitor pattern & AST generation**:  
  - automated AST code generation (`ast_codegen.go` + `grammar.json`) produces strongly-typed node structs and visitor interfaces  
  - reduces boilerplate and ensures consistent AST node structure  

- **error recovery & reporting**:  
  - scanner logs lexical errors without halting tokenization  
  - parser uses `synchronize()` to skip tokens until a statement boundary after a parse error  
  - interpreter catches and reports runtime errors (type checks for operands, undefined variables, arity mismatches)  

- **environment chaining & closures**:  
  - nested `Environment` structs implement lexical scope resolution  
  - function declarations capture their defining environment as a closure for proper variable lookup at call time  

- **native host bindings**:  
  - example `clock()` native function returns current time  
  - easily extended to add new host functions (I/O, math, etc.)  
