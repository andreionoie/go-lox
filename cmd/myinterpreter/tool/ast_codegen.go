package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"io"
	"os"
	"text/template"
)

type Grammar struct {
	AstDefinitions []AstDefinition `json:"astDefinitions"`
}

type AstDefinition struct {
	BaseName    string       `json:"baseName"`
	Productions []Production `json:"productions"`
}

type Production struct {
	Head string     `json:"head"`
	Body []BodyItem `json:"body"`
}

type BodyItem struct {
	Type string `json:"type"`
	Name string `json:"name"`
}

const codeTemplate = `
// Code generated by ast_codegen.go; DO NOT EDIT.

package main
import "errors"

{{ range .AstDefinitions }}
{{ $astDefinition := . }}
{{ $visitorInterfaceName := print $astDefinition.BaseName "Visitor" }}
	// define the base {{ $astDefinition.BaseName }} (5.2.2 Metaprogramming the trees)
	type {{ $astDefinition.BaseName }} interface {
		// define the abstract accept() function (5.3.3 Visitors for expressions)
		Accept(visitor {{ $visitorInterfaceName }}) (result interface{}, err error)
	}

	// define the visitor interface (5.3.3 Visitors for expressions)
	type {{ $visitorInterfaceName }} interface {
		{{ range $astDefinition.Productions }}
		{{ $productionFullName := print .Head $astDefinition.BaseName }}
			Visit{{ $productionFullName }}(v *{{ $productionFullName }}) (result interface{}, err error)
		{{ end }}
	}

	type Stub{{ $visitorInterfaceName }} struct{}
	// type assertion to ensure stub implements all
	var _ {{ $visitorInterfaceName }} = Stub{{ $visitorInterfaceName }} {}

	{{ range $astDefinition.Productions }}
	{{ $productionFullName := print .Head $astDefinition.BaseName }}
		func (s Stub{{ $visitorInterfaceName }}) Visit{{ $productionFullName }}(_ *{{ $productionFullName }}) (result interface{}, err error) {
			return nil, errors.New("visit func for {{ $productionFullName }} is not implemented")
		}
	{{ end }}

	{{ range $astDefinition.Productions }}
	{{ $productionFullName := print .Head $astDefinition.BaseName }}
		// define the subtype {{ .Head }} (5.2.2 Metaprogramming the trees)
		type {{ $productionFullName }} struct {
			{{ range .Body }}
				{{ .Name }} {{ .Type }}
			{{ end }}
		}

		// each subtype implements the abstract accept() and calls the right visit method (5.3.3 Visitors for expressions)
		func (b *{{ $productionFullName }}) Accept(visitor {{ $visitorInterfaceName }}) (result interface{}, err error) {
			return visitor.Visit{{ $productionFullName }}(b)
		}

		var _ {{ $astDefinition.BaseName }} = (* {{ $productionFullName }} ) (nil)
	{{ end }}

{{ end }}
`

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Please provide a grammar file path as an argument")
		return
	}

	grammarFile, err := os.Open(os.Args[1])
	if err != nil {
		panic(err)
	}
	defer grammarFile.Close()

	grammarFileBytes, err := io.ReadAll(grammarFile)
	if err != nil {
		panic(err)
	}

	var grammar Grammar
	err = json.Unmarshal(grammarFileBytes, &grammar)
	if err != nil {
		panic(err)
	}

	fmt.Printf("Grammar: %+v\n", grammar)

	tmpl, err := template.New("myTempl").Parse(codeTemplate)
	if err != nil {
		panic(err)
	}

	var codegenBuf bytes.Buffer
	err = tmpl.Execute(&codegenBuf, grammar)
	if err != nil {
		panic(err)
	}

	codegenFormatted, err := format.Source(codegenBuf.Bytes())
	if err != nil {
		panic(err)
	}

	codegenOut, err := os.Create("ast.generated.go")
	if err != nil {
		panic(err)
	}
	defer codegenOut.Close()

	_, err = codegenOut.Write(codegenFormatted)
	if err != nil {
		panic(err)
	}
}
